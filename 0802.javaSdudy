#2013.8.2 자바수업 교육내용 로그 정리




*[명령어 묶기 개념] 
- 기능별로 묶는다 : functional ==>함수형
-COBOL에선 Procedure라고 함
-[function(함수)를 묶기위해 생긴 개념이 바로 class이다.]


*[형상관리란?]
-소프트웨어 변경을 관리한다. ==> 즉 소스를 관리하겠다는 의미
-Configuration Management 줄여서 CM 이라고한다 ==>  CM/SCM 
-Version Control System 이라고도 불리워진다
-대표적 도구들 ===  CVS / SVN / GIT
-그밖에 유료버전 도구들 ==> Cleat Case / Sourceface / ..etc


-SVN 충돌시 해결방법 : 충돌난 소스를 다시 Merge하여 commit !!







[계산기  프로그램 만들기 ]


#패키지명: package net.bitacademy.java41.step05;;
-CalcTest.java
-Calculator.java


-CalcTest.java 소스

```java
ackage net.bitacademy.java41.step05;


// 1. java -classpath .... net.bitacademy.java41.step05.CalcTest
// 2. CalcTest.class 파일을 Method Area 영역에 로딩
// * 클래스 로딩
//   1) 클래스 파일이 유효한지 검사
//   2) static 변수 준비
//  3) static 블럭 수행
// 3. main() 메서드 호출
// 4. Stack 영역에 main() 메서드의 로컬 변수를 준비
// 5. main() 메서드의 명령어 실행 중 Calculator.init() 호출문을 만나면, 
// Calculator 클래스 로딩
//  ....


public class CalcTest {
public static void main(String[] args) {
// (10 + 20) * 3 = 90
// 10 / 2 + 30 = 35

// 위의 계산을 병행하여 수행하기!
// 1. step03의 Calculator는 중간 계산결과를 보관하기 위해
//    클래스를 변수를 사용한다. ==> 병행 계산이 불가하다.
net.bitacademy.java41.step03.Calculator.init(10);
net.bitacademy.java41.step03.Calculator.init(10);


net.bitacademy.java41.step03.Calculator.compute("+", 20);
net.bitacademy.java41.step03.Calculator.compute("/", 2);


net.bitacademy.java41.step03.Calculator.compute("*", 3);
net.bitacademy.java41.step03.Calculator.compute("+", 30);

System.out.println( net.bitacademy.java41.step03.Calculator.getResult());

// 중간 계산 결과를 개별적으로 관리하기 방안 필요!
// ==> 역할을 수행하는 동안 사용되는 값을 개별화 시키는 기법
// ==> 인스턴스화
// ==> 개별적으로 관리되어야 할 값은 인스턴스 변수에 저장해야 한다.
// ==> 인스턴스 변수 만들기? static 을 빼라!
// Calculator의 인스턴스 변수를 두 개 준비한다.

// stack 메모리 영역
// - 메서드에서 만드는 로컬 변수를 저장
// - 메서드 호출이 끝나면 그 메서드를 위해 만들었던 모든 변수를 삭제.
// Heap 메모리 영역
// - 인스턴스 변수를 저장

Calculator c1 = new Calculator(); // JVM에게 명령하노니, 
   // Calculator 클래스를 확인하여 인스턴스 변수가
                  // 있다면 해당 변수를 Heap 영역에 준비하라!
  // => 인스턴스 생성! 
 // => 인스턴스 변수가 시작되는 바이트의 주소를 리턴 
// c1 변수는 인스턴스의 시작 주소를 저장한다. 주소 변수. 포인터 변수.

Calculator c2 = new Calculator();

// c1: (10 + 20) * 3 = 90
// c2: 10 / 2 + 30 = 35

c1.init(10);
c2.init(10);

c1.compute("+", 20);
c2.compute("/", 2);

c1.compute("*", 3);
c2.compute("+", 30);

System.out.println(c1.getResult());
System.out.println(c2.getResult());

}


}


```

--Calculator.java 소스

```java
package net.bitacademy.java41.step05;


public class Calculator {
// 중간 계산 결과를 저장할 변수 준비
// 인스턴스 메서드
// - static 붙지 않는다.
// - 호출할 때 반드시 인스턴스 주소를 앞에 붙여야 한다.
//   ex) c1.compute(...)
private int result;

public void init(/*Calculator this,*/ int v1) {
this.result = v1;
}

public int getResult(/*Calculator this,*/) {
return this.result;
}

public int compute(/*Calculator this,*/ String op, int v1) {
switch(op) {
case "+":
this.result = plus(this.result, v1); break;
case "-":
this.result = minus(this.result, v1); break;
case "*":
this.result = multiple(this.result, v1); break;
case "/":
this.result = divide(this.result, v1); break;
}

return this.result;
}

private static int plus(int v1, int v2) {
return v1 + v2;
}

private static int minus(int v1, int v2) {
return v1 - v2;
}

private static int multiple(int v1, int v2) {
return v1 * v2;
}

private static int divide(int v1, int v2) {
return v1 / v2;
}
}

```
[인스턴스 관련 자료]


인스턴스는 추상화 개념 또는 클래스 객체, 컴퓨터 프로세스 등과 같은 템플릿이 실제 구현된 것이다. 인스턴스화는 클래스 내의 객체에 대해 특정한 변형을 정의하고, 이름을 붙인 다음, 그것을 물리적인 어떤 장소에 위치시키는 등의 작업을 통해, 인스턴스를 만드는 것을 의미한다.

  1. 몇몇 필자들은, 객체지향 프로그래밍에서 클래스를 인스턴스화 한다는 것이, 클래스의 구체적인 인스턴스, 즉 객체를 만드는 것이라고 말한다. 그 객체는 컴퓨터 내에서 실행시킬 수 있는 실행 파일이다.

	2. 객체지향 프로그램 언어인 자바에서는, 클래스로부터 인스턴스화된 객체를, 객체라는 말 대신에 역시 클래스라고 부름으로써 많은 사용자들을 혼란스럽게 한다. 즉 자바에서는, 특정한 클래스를 만들기 위해 클래스를 인스턴스화하며, 그것 역시 컴퓨터 내에서 동작하는 실행 파일이다.

	3. 객체지향 프로그래밍 개념이 나오기 이전의 데이터 모델링이나 프로그래밍에서는, 인스턴스화라는 것이 관계형 데이터베이스 테이블 내에 새로운 엔트리를 만듦으로써 추상화된 객체로부터 실재(데이터가 들어있는) 객체를 만드는 것도, 한 가지 용례였다.





#[여기서 잠깐 !! 자바 메모리 로딩 관련자료에 대하여..]
-java 에서 프로그램을 실행한다는 것은 class파일을 JVM으로
 로딩하고 Bytecode를 해석하는(바로 인터프리터 하는일..)하는
작업은 물론, 메모리등의 리소스를 할당하고 관리하며 정보를 처리하는
 일련의 작업들을 포함한다.이때 JVM은 스레드 관리 및 가비지콜렉션 같은
메모리 재생작업도 수행합니다.

[로딩]
윈도우 시스템에서 실행파일은 PE(Portable Excutable)파일 형식을 가지고 있다.
Visual studio로 컴파일하면 .exe확장자를 가진 파일을 생성하게 되는데 바로 이 파일이
PE파일형식을 가지고 있어서 프로그램실행 명령이 내려지면 OS는 PE파일릐 header부분을 분석해 프로그램 진입지점을 적절하게 메인 메모리에 로딩하게 된다.
그후 프로그램의 명령에 따라 필요한 순차적으로 명령어들을 로딩하게 된다.







